experiment:
  server:
    hostname: thinkpad
    cpu_description: AMD Ryzen 5 5500U
    hertz: 2.1
    cores: 6
    threads: 12
    ram_memory: 16
    operating_system: Ubuntu 25.04
  benchmarks:
    - name: "2mm"
      version: 0
      path: ./applications/2mm
      setup: "mkdir -p $PATH/output ./report/2mm"
      description: "Multiply two matrixes with this result multiply with another matrix and output the result as a csv like structure (without the header)."
    - name: "correlation"
      version: 0
      path: ./applications/correlation
      setup: "mkdir -p $PATH/output  ./report/correlation"
      description: "Calculate the correlation between all columns of a csv file."
    - name: "deriche"
      version: 0
      path: ./applications/deriche
      setup: "mkdir -p $PATH/output  ./report/deriche"
      description: "Deriche is a edge detector algorithm based on the canny edge detector algorithm."
    - name: "jacobi2d"
      version: 0
      path: ./applications/jacobi2d
      setup: "mkdir -p $PATH/output  ./report/jacobi2d"
      description: "Performs a 2D Jacobi relaxation method on a square grid. Iteratively updates each cell in the grid to the average of its four neighbors. Used for solving partial differential equations such as Laplace''s equation."
    - name: "mandelbrot"
      version: 0
      path: ./applications/mandelbrot
      setup: "mkdir -p $PATH/output  ./report/mandelbrot"
      description: "Calculates the mandelbrot set and ouputs it as a 1-bit P4 portable bitmap image."
    - name: "pi"
      version: 0
      path: ./applications/pi
      setup: "mkdir -p $PATH/output  ./report/pi"
      description: "Calculates the PI number based on the Monte Carlo distribution."
    - name: "kmeans"
      version: 0
      path: ./applications/kmeans
      setup: "mkdir -p $PATH/output  ./report/kmeans"
      description: "Divides a dataset into a given number of clusters. The algorithm starts by randomly selecting initial cluster centers, then iteratively assigns each point to the nearest cluster center."
  executions:
    - bench_name: 2mm
      bench_version: 0
      num_executions: 10
      num_threads: [1, 2, 4, 8, 16]
      inputs:
        matrix_size: 256
        output: output.csv
      variants:
        - type: common
          compile: "make -C $PATH"
          pos_processing: 'duckdb -c "COPY (SELECT * FROM read_csv_auto(''output.csv'')) TO ''$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet'' (FORMAT PARQUET);" && rm -f output.csv'
          baseline: true
          env_vars:
            OMP_PROC_BIND: "TRUE"
        - type: omp
          compile: "make NUM_THREADS=$NUM_THREADS -C $PATH omp"
          pos_processing: 'duckdb -c "COPY (SELECT * FROM read_csv_auto(''output.csv'')) TO ''$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet'' (FORMAT PARQUET);" && rm -f output.csv'
          metric:
            type: MAPE
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.parquet
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.parquet
          env_vars:
            OMP_PROC_BIND: "TRUE"
        - type: approx
          approx_type: perfo_init
          approx_rates: [10, 20, 30, 40, 50]
          compile: "make NUM_THREADS=$NUM_THREADS DROP=$APPROX_RATE -C $PATH perfo_init"
          pos_processing: 'duckdb -c "COPY (SELECT * FROM read_csv_auto(''output.csv'')) TO ''$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet'' (FORMAT PARQUET);" && rm -f output.csv'
          metric:
            type: MAPE
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.parquet
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.parquet
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
        - type: approx
          approx_type: perfo_fini
          approx_rates: [10, 20, 30, 40, 50]
          compile: "make NUM_THREADS=$NUM_THREADS DROP=$APPROX_RATE -C $PATH perfo_fini"
          pos_processing: 'duckdb -c "COPY (SELECT * FROM read_csv_auto(''output.csv'')) TO ''$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet'' (FORMAT PARQUET);" && rm -f output.csv'
          metric:
            type: MAPE
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.parquet
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.parquet
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
        - type: approx
          approx_type: perfo_large
          approx_rates: [10, 20, 30, 40, 50]
          compile: "make NUM_THREADS=$NUM_THREADS DROP=$APPROX_RATE -C $PATH perfo_large"
          pos_processing: 'duckdb -c "COPY (SELECT * FROM read_csv_auto(''output.csv'')) TO ''$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet'' (FORMAT PARQUET);" && rm -f output.csv'
          metric:
            type: MAPE
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.parquet
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.parquet
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
        - type: approx
          approx_type: fastmath
          compile: "make NUM_THREADS=$NUM_THREADS -C $PATH fastmath"
          pos_processing: 'duckdb -c "COPY (SELECT * FROM read_csv_auto(''output.csv'')) TO ''$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet'' (FORMAT PARQUET);" && rm -f output.csv'
          metric:
            type: MAPE
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.parquet
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.parquet
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
    - bench_name: correlation
      bench_version: 0
      num_executions: 10
      num_threads: [1, 2, 4, 8, 16]
      inputs:
        input: $PATH/input/input.csv
        output: output.csv
      variants:
        - type: common
          compile: "make -C $PATH"
          pos_processing: 'duckdb -c "COPY (SELECT * FROM read_csv_auto(''output.csv'')) TO ''$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet'' (FORMAT PARQUET);" && rm -f output.csv'
          baseline: true
          env_vars:
            OMP_PROC_BIND: "TRUE"
        - type: omp
          compile: "make NUM_THREADS=$NUM_THREADS -C $PATH omp"
          pos_processing: 'duckdb -c "COPY (SELECT * FROM read_csv_auto(''output.csv'')) TO ''$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet'' (FORMAT PARQUET);" && rm -f output.csv'
          metric:
            type: MAPE
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.parquet
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.parquet
          env_vars:
            OMP_PROC_BIND: "TRUE"
        - type: approx
          approx_type: perfo_init
          approx_rates: [10, 20, 30, 40, 50]
          compile: "make NUM_THREADS=$NUM_THREADS DROP=$APPROX_RATE -C $PATH perfo_init"
          pos_processing: 'duckdb -c "COPY (SELECT * FROM read_csv_auto(''output.csv'')) TO ''$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet'' (FORMAT PARQUET);" && rm -f output.csv'
          metric:
            type: MAPE
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.parquet
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.parquet
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
        - type: approx
          approx_type: perfo_fini
          approx_rates: [10, 20, 30, 40, 50]
          compile: "make NUM_THREADS=$NUM_THREADS DROP=$APPROX_RATE -C $PATH perfo_fini"
          pos_processing: 'duckdb -c "COPY (SELECT * FROM read_csv_auto(''output.csv'')) TO ''$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet'' (FORMAT PARQUET);" && rm -f output.csv'
          metric:
            type: MAPE
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.parquet
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.parquet
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
        - type: approx
          approx_type: perfo_large
          approx_rates: [10, 20, 30, 40, 50]
          compile: "make NUM_THREADS=$NUM_THREADS DROP=$APPROX_RATE -C $PATH perfo_large"
          pos_processing: 'duckdb -c "COPY (SELECT * FROM read_csv_auto(''output.csv'')) TO ''$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet'' (FORMAT PARQUET);" && rm -f output.csv'
          metric:
            type: MAPE
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.parquet
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.parquet
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
        - type: approx
          approx_type: fastmath
          compile: "make NUM_THREADS=$NUM_THREADS -C $PATH fastmath"
          pos_processing: 'duckdb -c "COPY (SELECT * FROM read_csv_auto(''output.csv'')) TO ''$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet'' (FORMAT PARQUET);" && rm -f output.csv'
          metric:
            type: MAPE
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.parquet
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.parquet
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
    - bench_name: deriche
      bench_version: 0
      num_executions: 10
      num_threads: [1, 2, 4, 8, 16]
      inputs:
        alpha: 0.5
        input: $PATH/input/sunflower.jpg
        output: output.jpg
      variants:
        - type: common
          compile: "make -C $PATH"
          pos_processing: "mv output.jpg $PATH/output/output_$ID_GROUPg_$ID_RUN.jpg"
          baseline: true
          env_vars:
            OMP_PROC_BIND: "TRUE"
        - type: omp
          compile: "make NUM_THREADS=$NUM_THREADS -C $PATH omp"
          pos_processing: "mv output.jpg $PATH/output/output_$ID_GROUPg_$ID_RUN.jpg"
          metric:
            type: SSIM
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.jpg
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.jpg
          env_vars:
            OMP_PROC_BIND: "TRUE"
        - type: approx
          approx_type: perfo_init
          approx_rates: [10, 20, 30, 40, 50]
          compile: "make NUM_THREADS=$NUM_THREADS DROP=$APPROX_RATE -C $PATH perfo_init"
          pos_processing: "mv output.jpg $PATH/output/output_$ID_GROUPg_$ID_RUN.jpg"
          metric:
            type: SSIM
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.jpg
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.jpg
          env_vars:
            OMP_PROC_BIND: "TRUE"
        - type: approx
          approx_type: perfo_fini
          approx_rates: [10, 20, 30, 40, 50]
          compile: "make NUM_THREADS=$NUM_THREADS DROP=$APPROX_RATE -C $PATH perfo_fini"
          pos_processing: "mv output.jpg $PATH/output/output_$ID_GROUPg_$ID_RUN.jpg"
          metric:
            type: SSIM
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.jpg
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.jpg
          env_vars:
            OMP_PROC_BIND: "TRUE"
        - type: approx
          approx_type: perfo_large
          approx_rates: [10, 20, 30, 40, 50]
          compile: "make NUM_THREADS=$NUM_THREADS DROP=$APPROX_RATE -C $PATH perfo_large"
          pos_processing: "mv output.jpg $PATH/output/output_$ID_GROUPg_$ID_RUN.jpg"
          metric:
            type: SSIM
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.jpg
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.jpg
          env_vars:
            OMP_PROC_BIND: "TRUE"
        - type: approx
          approx_type: fastmath
          compile: "make NUM_THREADS=$NUM_THREADS -C $PATH fastmath"
          pos_processing: "mv output.jpg $PATH/output/output_$ID_GROUPg_$ID_RUN.jpg"
          metric:
            type: MAPE
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.parquet
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.parquet
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
    - bench_name: jacobi2d
      bench_version: 0
      num_executions: 10
      num_threads: [1, 2, 4, 8, 16]
      inputs:
        matrix_size: 2048
        num_steps: 5
        output: output.csv
      variants:
        - type: common
          compile: "make -C $PATH"
          pos_processing: 'duckdb -c "COPY (SELECT * FROM read_csv_auto(''output.csv'')) TO ''$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet'' (FORMAT PARQUET);" && rm -f output.csv'
          baseline: true
          env_vars:
            OMP_PROC_BIND: "TRUE"
        - type: omp
          compile: "make NUM_THREADS=$NUM_THREADS -C $PATH omp"
          pos_processing: 'duckdb -c "COPY (SELECT * FROM read_csv_auto(''output.csv'')) TO ''$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet'' (FORMAT PARQUET);" && rm -f output.csv'
          metric:
            type: MAPE
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.parquet
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.parquet
          env_vars:
            OMP_PROC_BIND: "TRUE"
        - type: approx
          approx_type: perfo_init
          approx_rates: [10, 20, 30, 40, 50]
          compile: "make NUM_THREADS=$NUM_THREADS DROP=$APPROX_RATE -C $PATH perfo_init"
          pos_processing: 'duckdb -c "COPY (SELECT * FROM read_csv_auto(''output.csv'')) TO ''$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet'' (FORMAT PARQUET);" && rm -f output.csv'
          metric:
            type: MAPE
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.parquet
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.parquet
          env_vars:
            OMP_PROC_BIND: "TRUE"
        - type: approx
          approx_type: perfo_fini
          approx_rates: [10, 20, 30, 40, 50]
          compile: "make NUM_THREADS=$NUM_THREADS DROP=$APPROX_RATE -C $PATH perfo_fini"
          pos_processing: 'duckdb -c "COPY (SELECT * FROM read_csv_auto(''output.csv'')) TO ''$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet'' (FORMAT PARQUET);" && rm -f output.csv'
          metric:
            type: MAPE
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.parquet
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.parquet
          env_vars:
            OMP_PROC_BIND: "TRUE"
        - type: approx
          approx_type: perfo_large
          approx_rates: [10, 20, 30, 40, 50]
          compile: "make NUM_THREADS=$NUM_THREADS DROP=$APPROX_RATE -C $PATH perfo_large"
          pos_processing: 'duckdb -c "COPY (SELECT * FROM read_csv_auto(''output.csv'')) TO ''$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet'' (FORMAT PARQUET);" && rm -f output.csv'
          metric:
            type: MAPE
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.parquet
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.parquet
          env_vars:
            OMP_PROC_BIND: "TRUE"
        - type: approx
          approx_type: fastmath
          compile: "make NUM_THREADS=$NUM_THREADS -C $PATH fastmath"
          pos_processing: 'duckdb -c "COPY (SELECT * FROM read_csv_auto(''output.csv'')) TO ''$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet'' (FORMAT PARQUET);" && rm -f output.csv'
          metric:
            type: MAPE
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.parquet
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.parquet
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
    - bench_name: mandelbrot
      bench_version: 0
      num_executions: 10
      num_threads: [1, 2, 4, 8, 16]
      inputs:
        image_size: 2048
        output_img: output.bmp
      variants:
        - type: common
          compile: "make -C $PATH"
          pos_processing: "mv output.bmp $PATH/output/output_$ID_GROUPg_$ID_RUN.bmp"
          baseline: true
          env_vars:
            OMP_PROC_BIND: "TRUE"
        - type: omp
          compile: "make NUM_THREADS=$NUM_THREADS -C $PATH omp"
          pos_processing: "mv output.bmp $PATH/output/output_$ID_GROUPg_$ID_RUN.bmp"
          metric:
            type: SSIM
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.bmp
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.bmp
          env_vars:
            OMP_PROC_BIND: "TRUE"
        - type: approx
          approx_type: perfo_init
          approx_rates: [10, 20, 30, 40, 50]
          compile: "make NUM_THREADS=$NUM_THREADS DROP=$APPROX_RATE -C $PATH perfo_init"
          pos_processing: "mv output.bmp $PATH/output/output_$ID_GROUPg_$ID_RUN.bmp"
          metric:
            type: SSIM
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.bmp
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.bmp
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
        - type: approx
          approx_type: perfo_fini
          approx_rates: [10, 20, 30, 40, 50]
          compile: "make NUM_THREADS=$NUM_THREADS DROP=$APPROX_RATE -C $PATH perfo_fini"
          pos_processing: "mv output.bmp $PATH/output/output_$ID_GROUPg_$ID_RUN.bmp"
          metric:
            type: SSIM
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.bmp
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.bmp
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
        - type: approx
          approx_type: perfo_large
          approx_rates: [10, 20, 30, 40, 50]
          compile: "make NUM_THREADS=$NUM_THREADS DROP=$APPROX_RATE -C $PATH perfo_large"
          pos_processing: "mv output.bmp $PATH/output/output_$ID_GROUPg_$ID_RUN.bmp"
          metric:
            type: SSIM
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.bmp
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.bmp
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
        - type: approx
          approx_type: fastmath
          compile: "make NUM_THREADS=$NUM_THREADS -C $PATH fastmath"
          pos_processing: "mv output.bmp $PATH/output/output_$ID_GROUPg_$ID_RUN.bmp"
          metric:
            type: SSIM
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.bmp
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.bmp
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
    - bench_name: pi
      bench_version: 0
      num_executions: 10
      num_threads: [1, 2, 4, 8, 16]
      inputs:
        num_iterations: 4096
        file_output: output.csv
      variants:
        - type: common
          compile: "make -C $PATH"
          pos_processing: "mv output.csv $PATH/output/output_$ID_GROUPg_$ID_RUN.csv"
          baseline: true
          env_vars:
            OMP_PROC_BIND: "TRUE"
        - type: omp
          compile: "make NUM_THREADS=$NUM_THREADS -C $PATH omp"
          pos_processing: "mv output.csv $PATH/output/output_$ID_GROUPg_$ID_RUN.csv"
          metric:
            type: RMSE
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.csv
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.csv
          env_vars:
            OMP_PROC_BIND: "TRUE"
        - type: approx
          approx_type: fastmath
          compile: "make NUM_THREADS=$NUM_THREADS -C $PATH fastmath"
          pos_processing: "mv output.csv $PATH/output/output_$ID_GROUPg_$ID_RUN.csv"
          metric:
            type: RMSE
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.csv
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.csv
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
        - type: approx
          approx_type: perfo_init
          approx_rates: [10, 20, 30, 40, 50]
          compile: "make NUM_THREADS=$NUM_THREADS DROP=$APPROX_RATE -C $PATH perfo_init"
          pos_processing: "mv output.csv $PATH/output/output_$ID_GROUPg_$ID_RUN.csv"
          metric:
            type: RMSE
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.csv
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.csv
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
        - type: approx
          approx_type: perfo_fini
          approx_rates: [10, 20, 30, 40, 50]
          compile: "make NUM_THREADS=$NUM_THREADS DROP=$APPROX_RATE -C $PATH perfo_fini"
          pos_processing: "mv output.csv $PATH/output/output_$ID_GROUPg_$ID_RUN.csv"
          metric:
            type: RMSE
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.csv
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.csv
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
        - type: approx
          approx_type: perfo_large
          approx_rates: [10, 20, 30, 40, 50]
          compile: "make NUM_THREADS=$NUM_THREADS DROP=$APPROX_RATE -C $PATH perfo_large"
          pos_processing: "mv output.csv $PATH/output/output_$ID_GROUPg_$ID_RUN.csv"
          metric:
            type: RMSE
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.csv
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.csv
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
    - bench_name: kmeans
      bench_version: 0
      num_executions: 10
      num_threads: [1, 2, 4, 8, 16]
      inputs:
        num_clusters: 10
        iterations: 100
        threshold: 5
        input_file: $PATH/input/kdd_cup.csv
        output_file: output.txt
      variants:
        - type: common
          compile: "make -C $PATH"
          pos_processing: |
            cut -d' ' -f2- output.txt | awk -F, '{ for (i=1; i<=NF; i++) a[i,NR]=$i; if (NF>max_f) max_f=NF } END { for (i=1; i<=max_f; i++) { for (j=1; j<=NR; j++) printf "%s%s", a[i,j], (j==NR ? "" : ","); print "" } }' > output.csv && duckdb -c "COPY (SELECT * FROM read_csv_auto('output.csv')) TO '$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet' (FORMAT PARQUET);" && rm -f output.txt output.csv
          baseline: true
          env_vars:
            OMP_PROC_BIND: "TRUE"
        - type: omp
          compile: "make NUM_THREADS=$NUM_THREADS -C $PATH omp"
          pos_processing: |
            cut -d' ' -f2- output.txt | awk -F, '{ for (i=1; i<=NF; i++) a[i,NR]=$i; if (NF>max_f) max_f=NF } END { for (i=1; i<=max_f; i++) { for (j=1; j<=NR; j++) printf "%s%s", a[i,j], (j==NR ? "" : ","); print "" } }' > output.csv && duckdb -c "COPY (SELECT * FROM read_csv_auto('output.csv')) TO '$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet' (FORMAT PARQUET);" && rm -f output.txt output.csv
          metric:
            type: MCR
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.parquet
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.parquet
          env_vars:
            OMP_PROC_BIND: "TRUE"
        - type: approx
          approx_type: fastmath
          compile: "make NUM_THREADS=$NUM_THREADS -C $PATH fastmath"
          pos_processing: |
            cut -d' ' -f2- output.txt | awk -F, '{ for (i=1; i<=NF; i++) a[i,NR]=$i; if (NF>max_f) max_f=NF } END { for (i=1; i<=max_f; i++) { for (j=1; j<=NR; j++) printf "%s%s", a[i,j], (j==NR ? "" : ","); print "" } }' > output.csv && duckdb -c "COPY (SELECT * FROM read_csv_auto('output.csv')) TO '$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet' (FORMAT PARQUET);" && rm -f output.txt output.csv
          metric:
            type: MCR
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.parquet
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.parquet
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
        - type: approx
          approx_type: perfo_init
          approx_rates: [10, 20, 30, 40, 50]
          compile: "make NUM_THREADS=$NUM_THREADS DROP=$APPROX_RATE -C $PATH perfo_init"
          pos_processing: |
            cut -d' ' -f2- output.txt | awk -F, '{ for (i=1; i<=NF; i++) a[i,NR]=$i; if (NF>max_f) max_f=NF } END { for (i=1; i<=max_f; i++) { for (j=1; j<=NR; j++) printf "%s%s", a[i,j], (j==NR ? "" : ","); print "" } }' > output.csv && duckdb -c "COPY (SELECT * FROM read_csv_auto('output.csv')) TO '$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet' (FORMAT PARQUET);" && rm -f output.txt output.csv
          metric:
            type: MCR
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.parquet
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.parquet
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
        - type: approx
          approx_type: perfo_fini
          approx_rates: [10, 20, 30, 40, 50]
          compile: "make NUM_THREADS=$NUM_THREADS DROP=$APPROX_RATE -C $PATH perfo_fini"
          pos_processing: |
            cut -d' ' -f2- output.txt | awk -F, '{ for (i=1; i<=NF; i++) a[i,NR]=$i; if (NF>max_f) max_f=NF } END { for (i=1; i<=max_f; i++) { for (j=1; j<=NR; j++) printf "%s%s", a[i,j], (j==NR ? "" : ","); print "" } }' > output.csv && duckdb -c "COPY (SELECT * FROM read_csv_auto('output.csv')) TO '$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet' (FORMAT PARQUET);" && rm -f output.txt output.csv
          metric:
            type: MCR
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.parquet
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.parquet
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
        - type: approx
          approx_type: perfo_large
          approx_rates: [10, 20, 30, 40, 50]
          compile: "make NUM_THREADS=$NUM_THREADS DROP=$APPROX_RATE -C $PATH perfo_large"
          pos_processing: |
            cut -d' ' -f2- output.txt | awk -F, '{ for (i=1; i<=NF; i++) a[i,NR]=$i; if (NF>max_f) max_f=NF } END { for (i=1; i<=max_f; i++) { for (j=1; j<=NR; j++) printf "%s%s", a[i,j], (j==NR ? "" : ","); print "" } }' > output.csv && duckdb -c "COPY (SELECT * FROM read_csv_auto('output.csv')) TO '$PATH/output/output_$ID_GROUPg_$ID_RUN.parquet' (FORMAT PARQUET);" && rm -f output.txt output.csv
          metric:
            type: MCR
            reference: $PATH/output/output_$ID_GROUP_BASEg_$ID_BASE.parquet
            prediction: $PATH/output/output_$ID_GROUPg_$ID_RUN.parquet
          env_vars:
            OMP_PROC_BIND: "TRUE"
            OMP_APPROX: "TRUE"
